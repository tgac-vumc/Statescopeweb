"use strict";(self.webpackChunkStatescope=self.webpackChunkStatescope||[]).push([[8878],{3226:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"advanced-tutorial_python","title":"Advanced Tutorial on Python","description":"Introduction","source":"@site/docs/advanced-tutorial_python.md","sourceDirName":".","slug":"/advanced-tutorial_python","permalink":"/Statescopeweb/docs/advanced-tutorial_python","draft":false,"unlisted":false,"editUrl":"https://github.com/tgac-vumc/Statescopeweb.git/docs/advanced-tutorial_python.md","tags":[],"version":"current","frontMatter":{"id":"advanced-tutorial_python","title":"Advanced Tutorial on Python"},"sidebar":"tutorialSidebar","previous":{"title":"Basic Tutorial Python","permalink":"/Statescopeweb/docs/python"},"next":{"title":"Visualisation Functions (Python)","permalink":"/Statescopeweb/docs/visualisation-functions-python"}}');var i=s(4848),n=s(8453);const l={id:"advanced-tutorial_python",title:"Advanced Tutorial on Python"},o=void 0,r={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Read and visualize scRNAseq dataset and annotations",id:"read-and-visualize-scrnaseq-dataset-and-annotations",level:2},{value:"Statescope initialization",id:"statescope-initialization",level:2},{value:"Statescope deconvolution",id:"statescope-deconvolution",level:2},{value:"Optional: Preparing the prior tumor fraction for Statescope deconvolution: Group prior",id:"optional-preparing-the-prior-tumor-fraction-for-statescope-deconvolution-group-prior",level:2},{value:"Now we will run the Deconvolution with default parameters",id:"now-we-will-run-the-deconvolution-with-default-parameters",level:2},{value:"Statescope Refinement",id:"statescope-refinement",level:2},{value:"Statescope State Discovery",id:"statescope-state-discovery",level:2},{value:"Evaluate State Discovery: K parameter",id:"evaluate-state-discovery-k-parameter",level:2},{value:"PDAC intratumor heterogeneity",id:"pdac-intratumor-heterogeneity",level:2},{value:"Statescope results and plotting functions",id:"statescope-results-and-plotting-functions",level:2},{value:"1. Investigate whether the &#39;Eptithelial&#39; state loadings correspond to well established Classical and Basal markers in literature",id:"1-investigate-whether-the-eptithelial-state-loadings-correspond-to-well-established-classical-and-basal-markers-in-literature",level:2},{value:"2. Investigate whether &#39;Epithelial&#39; state scores correspond to the Basal/Classical fractions of the detailed model",id:"2-investigate-whether-epithelial-state-scores-correspond-to-the-basalclassical-fractions-of-the-detailed-model",level:2},{value:"3. Investigate whether &#39;Epithelial&#39; states retrieved in scRNAseq profiles (StateRetrieval) correspond to Classic/Basal cells",id:"3-investigate-whether-epithelial-states-retrieved-in-scrnaseq-profiles-stateretrieval-correspond-to-classicbasal-cells",level:2},{value:"State Retrieval",id:"state-retrieval",level:2},{value:"Saving, Loading, and CPU/GPU Interoperability",id:"saving-loading-and-cpugpu-interoperability",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(t.p,{children:"In this tutorial, we will demonstrate the functionality of the Statescope framework for advanced users:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Create a custom signature from scRNAseq data"}),"\n",(0,i.jsx)(t.li,{children:"Use prior expectations for tumor cell fractions, both in single mode (simple model) and group-mode (detailed model, split into Basal/Classical)"}),"\n",(0,i.jsx)(t.li,{children:"Perform Downstream analysis and interpretation in PDAC application, including retrieval of states in single cell profiles (StateRetrieval)"}),"\n",(0,i.jsx)(t.li,{children:"We will perform deconvolution, refinement and state discovery on the TCGA-PAAD bulk transcriptome dataset of PDAC samples using a custom scRNAseq signature"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Import libraries: All libraries (dependencies) used in this notebook are accompanied with Statescope (installation with pip install Statescope)\nimport Statescope.Statescope as scope\nimport pandas as pd\nimport anndata\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Read TCGA-PAAD dataset, stored locally and retrieved from https://portal.gdc.cancer.gov/projects/TCGA-PAAD\nBulk = pd.read_csv('TCGA_PAAD_Count_Matrix.txt', sep = '\\t', index_col = 'gene')\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We will use a prior for the Tumor cell fractions to increase deconvolution performance. For the purpose of this notebook we will use ABSOLUTE (DNA-based) tumor purities generated by the TCGA (Raphael et al, 2017) and stored locally (source: ",(0,i.jsx)(t.a,{href:"https://ars.els-cdn.com/content/image/1-s2.0-S1535610817302994-mmc2.xlsx",children:"https://ars.els-cdn.com/content/image/1-s2.0-S1535610817302994-mmc2.xlsx"}),")."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Read ABSOLUTE DNA-based purity estimates\nTumor_purities = pd.read_csv('ABSOLUTE_Purities.txt', sep = '\\t', index_col = 'Tumor Sample ID')\nTumor_purities.index = ['-'.join(x.split('-')[0:3]) for x in Tumor_purities.index]\n# subset and match Bulk to samples with purity information available \nBulk = Bulk[Tumor_purities.index]\n"})}),"\n",(0,i.jsx)(t.h2,{id:"read-and-visualize-scrnaseq-dataset-and-annotations",children:"Read and visualize scRNAseq dataset and annotations"}),"\n",(0,i.jsx)(t.p,{children:"For this tutorial we will use phenotyped scRNAseq data to use as a signature"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Read publicly available, phenotyped scRNAseq dataset from Werba et al\n# We have classified Tumor cells into Classical and Basal cells based on the methods from Raghavan et al\nscRNAseq_dataset = anndata.read_h5ad('adata_werba.h5ad')\nscRNAseq_dataset\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# The annotations for the simple model are stored in the major_celltype column and the annotations for the detailed model are stored in the 'subtype' column\nprint('Simple model celltypes:',scRNAseq_dataset.obs.major_celltype.unique())\nprint('\\nDetailed model celltypes:',scRNAseq_dataset.obs.subtype.unique())\nscRNAseq_dataset.obs\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Visualize annotated UMAP used to create a signature\nfig, axes = plt.subplots(1, 2, figsize=(20, 10))\ncolor_pal = {'B/Plasma':'#FFBE7D','CAFs':'#ff9da7','Endothelial':'#B07AA1','Epithelial':'#E15759','Basal':'#E15759','Classical':'#F28E2B','Intermediate':'#D37295','Mast':'#79706E','Myeloid':'#9C755F','T/NK':'#59A14F'}\nsns.scatterplot(ax=axes[0], x=scRNAseq_dataset.obsm['X_umap'][:,0], y=scRNAseq_dataset.obsm['X_umap'][:,1], hue = scRNAseq_dataset.obs.major_celltype, s=2, palette = color_pal)\nsns.scatterplot(ax=axes[1], x=scRNAseq_dataset.obsm['X_umap'][:,0], y=scRNAseq_dataset.obsm['X_umap'][:,1], hue = scRNAseq_dataset.obs.subtype, s= 2, palette = color_pal)\nfig.show()\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"UMAP Annotated",src:s(3040).A+"",width:"1600",height:"817"})}),"\n",(0,i.jsx)(t.h2,{id:"statescope-initialization",children:"Statescope initialization"}),"\n",(0,i.jsx)(t.p,{children:"The first step in the Statescope analysis is the initialization of the object. In this notebook we will create two Statescope models, using the different annotations in the scRNAseq dataset ('major_celltype' and 'subtype'). When passing the annotated scRNAseq data to Statescope, a custom deconvolution signature is created with the cell types specified in the celtype_key as follows:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"The scRNAseq count data is validated (has to be library-size corrected and log-transformed)"}),"\n",(0,i.jsx)(t.li,{children:"The signature is created"}),"\n",(0,i.jsx)(t.li,{children:"The expected gene expression variability is corrected for highly expressed genes"}),"\n",(0,i.jsx)(t.li,{children:"Marker genes are detected using the AutoGeneS algorithm"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# First lets check the format of adata.X\n# Check if adata.X is in log, library-size corrected scaled\nscRNAseq_dataset.X # The counts seems to be scaled\n"})}),"\n",(0,i.jsx)(t.p,{children:"Now we will intialize the Statescope models and create the signatures using default parameters. The following paramters can be set:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"CorrectVariance (default=True); whether variance of high expressed genes should be corrected"}),"\n",(0,i.jsx)(t.li,{children:"n_highly_variable (default=3000); number of highly variable genes used for AutoGeneS"}),"\n",(0,i.jsx)(t.li,{children:"fixed_n_features (default = None); fixed number of AutoGeneS to be returned"}),"\n",(0,i.jsx)(t.li,{children:"MarkerList (default = None); Custom marker list to be used instead of AutoGeneS"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Initialize simple model\nStatescope_simple_model = scope.Initialize_Statescope(Bulk, Signature = scRNAseq_dataset, celltype_key = 'major_celltype')\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Initialize detailed model\nStatescope_detailed_model = scope.Initialize_Statescope(Bulk, Signature = scRNAseq_dataset, celltype_key = 'subtype')\n"})}),"\n",(0,i.jsx)(t.p,{children:"After intialization, several keys are added to the Statescope object which can be accessed at any time"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"print('First 10 markers:',Statescope_simple_model.Markers[0:10]) # Extra genes can also be manually added: model.Markers = model.Markers + ['MARKERNAME1','MARKERNAME2']\nprint('Celltypes:',Statescope_simple_model.Celltypes)\n"})}),"\n",(0,i.jsx)(t.h2,{id:"statescope-deconvolution",children:"Statescope deconvolution"}),"\n",(0,i.jsx)(t.p,{children:"The next step in the Statescope analysis is the deconvolution analysis. In this step, the intial optimization of the Statescope deconvolution module is performed. Here only marker genes are used and the cell fractions are estimated. First we will prepare the priors for the tumor fraction"}),"\n",(0,i.jsx)(t.p,{children:"Optional: Preparing the prior tumor fraction for Statescope deconvolution: Single prior"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Prepare the prior expectation for the tumor cell fraction\n# A single expectation is a pandas.Dataframe with shape (Nsample x Ncell)\n# Only cell types which are non-nan will be used as a prior\nExpectation_single = pd.DataFrame(np.nan, index=Statescope_simple_model.Samples, columns=Statescope_simple_model.Celltypes)\n# Fill in expected tumor fractions from ABSOLUTE\nExpectation_single.loc[:,'Epithelial']  = Tumor_purities.loc[Statescope_simple_model.Samples,'ABSOLUTE Purity']\nExpectation_single\n"})}),"\n",(0,i.jsx)(t.h2,{id:"optional-preparing-the-prior-tumor-fraction-for-statescope-deconvolution-group-prior",children:"Optional: Preparing the prior tumor fraction for Statescope deconvolution: Group prior"}),"\n",(0,i.jsx)(t.p,{children:"A group expectation is passed as a dictionary with two keys:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"'Expectation' : which is a numpy array identical to the single prior (with a prior given at index 0)"}),"\n",(0,i.jsx)(t.li,{children:"'Group' : which is an numpy array specifying with a value of 1 which cell types are in the group ( (Ncell-Ngroups) x Ncell)"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Prepare group Expectation\nExpectation_group = dict()\nGroup_cts = ['Basal','Classical','Intermediate']\nExpectation_group['Expectation'] = Expectation_single.to_numpy() # in the first column the expectation of the group is given\n# Create Ngroup x Ncell matrix with 0s, add the group row which has to be the same index as in the Expectation (in this case first row)\nGroups = pd.DataFrame(0, index = ['Group'] + [ct for ct in Statescope_detailed_model.Celltypes if not ct in Group_cts], columns = Statescope_detailed_model.Celltypes)\nGroups.loc['Group',Group_cts] = 1\nfor ct in Groups.columns:\n    if ct not in Group_cts:\n        Groups.loc[ct,ct] = 1\n\nprint('Expectation:\\n', Expectation_single.rename(columns={\"Epithelial\": \"Group\"}))\nprint('Group:\\n',Groups)\n# Add to dict\nExpectation_group['Group'] = Groups.to_numpy()\n"})}),"\n",(0,i.jsx)(t.h2,{id:"now-we-will-run-the-deconvolution-with-default-parameters",children:"Now we will run the Deconvolution with default parameters"}),"\n",(0,i.jsx)(t.p,{children:"The duration of the deconvolution scales with the number of marker genes, samples and cell types. When available, GPU computing is used, which is preferred and significantly increases computation performance"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Run Deconvolution for simple model with single tumor cell prior\nStatescope_simple_model.Deconvolution(Expectation = Expectation_single)\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Lets see if the posterior estimates of the Tumor fractions match the prior expectation\nplt.figure(figsize=(3,3))\nsns.scatterplot(x=Statescope_simple_model.Fractions.Epithelial, y=Expectation_single.Epithelial)\nplt.xlabel('Posterior'); plt.ylabel('Prior')\nplt.xlim(0,1); plt.ylim(0,1); plt.title('Epithelial fractions' )\nplt.show() # indeed the posterior is highly correlated, but not identical to, the prior\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Tumour Puritie Correllation",src:s(6913).A+"",width:"314",height:"316"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Run Deconvolution for detailed model with group tumor cell prior\nStatescope_detailed_model.Deconvolution(Expectation = Expectation_group)\n"})}),"\n",(0,i.jsx)(t.h2,{id:"statescope-refinement",children:"Statescope Refinement"}),"\n",(0,i.jsx)(t.p,{children:"The next step in the Statescope analysis is the Refinement analysis. In this step, all genes available in the signature are used to performed an additional optimization of the deconvolution. This step is introduced to capture more refined inter-sample variation in the gene expression profiles and is performed for each gene in parralell. The duration of this step decreases with more cores (or less genes) allocated to Statescope (in the intialize step). If only interested in a particular set of genes, a list of genes can be supplied to the 'GeneList' parameter"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"%%capture\nStatescope_simple_model.Refinement()\n"})}),"\n",(0,i.jsx)(t.h2,{id:"statescope-state-discovery",children:"Statescope State Discovery"}),"\n",(0,i.jsx)(t.p,{children:"The final step in the Statescope analysis is the State Discovery. In this step, the refined cell type-specific gene expression profiles are weighted and subjected to unsupervised clustering analysis using convex-NMF. The output of this module is the StateScores (Sample x K) and StateLoadings (Gene x K) for each cell type. By default, state discovery is performed for each cell type and the number of k is automatically selected based on an heuristic approach."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"%%capture\nStatescope_simple_model.StateDiscovery()\n"})}),"\n",(0,i.jsx)(t.h2,{id:"evaluate-state-discovery-k-parameter",children:"Evaluate State Discovery: K parameter"}),"\n",(0,i.jsx)(t.p,{children:"It is important to evaluate whether the automatically chosen values for k are sensible. We will create the Cophentic coefficient plot to evaluate the stability of the clustering for the different values of K. As a general rule of thumb, the value of k before the cohpenetic coefficient starts decreasing is the optimal one. It is important to consider that this behaviour can exist at different values of k (multi-modal shape of the plot), and that this approach is less reliable with small sample sizes."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"scope.Plot_CopheneticCoefficients(Statescope_simple_model)\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Cophenetic Coefficients",src:s(869).A+"",width:"3350",height:"390"})}),"\n",(0,i.jsx)(t.p,{children:"The red dot indicates the value of K chosen as the optimal model. For the Eptihelial cell type, three states were chosen. For some cell types, the model chosen seems suboptimal, presumably due to the parameters and relatively low sample size. Values for K can be manually adjusted as performed below."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Example of manually setting K for some cell types\nStatescope_simple_model.StateDiscovery(K={'Epithelial': 3,'T/NK': 4})\nscope.Plot_CopheneticCoefficients(Statescope_simple_model)\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Cophenetic Coefficients 2",src:s(9108).A+"",width:"3350",height:"390"})}),"\n",(0,i.jsx)(t.h2,{id:"pdac-intratumor-heterogeneity",children:"PDAC intratumor heterogeneity"}),"\n",(0,i.jsx)(t.p,{children:"In this notebook we will investigate whether the Epithelial states detected by the simple model correspond to the well defined Basal/Classical subtypes in a completely unsupervised manner. We will relate the findings of the simple model back to see if they correspond to the findings of the detailed model, in which additional prior knowledge (i.e. more supervised) was available."}),"\n",(0,i.jsx)(t.p,{children:"We will inspect:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"whether the 'Eptithelial' state loadings correspond to well established Classical and Basal markers in literature"}),"\n",(0,i.jsx)(t.li,{children:"whether 'Epithelial' state scores correspond to the Basal/Classical fractions of the detailed model"}),"\n",(0,i.jsx)(t.li,{children:"whether 'Epithelial' states retrieved in scRNAseq profiles (StateRetrieval) correspond to Classic/Basal cells"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"statescope-results-and-plotting-functions",children:"Statescope results and plotting functions"}),"\n",(0,i.jsx)(t.p,{children:"All results of the Statescope analysis are saved within the Statescope model (for example Statescope.Fractions, Statescope.GEX, Statescope.StateScores, Statescope.StateLoadings). In addition, we provide several functions for standard visualization of the results."}),"\n",(0,i.jsx)(t.h2,{id:"1-investigate-whether-the-eptithelial-state-loadings-correspond-to-well-established-classical-and-basal-markers-in-literature",children:"1. Investigate whether the 'Eptithelial' state loadings correspond to well established Classical and Basal markers in literature"}),"\n",(0,i.jsx)(t.p,{children:"Here we will inspect the 3 Epithelial states discovered by Statescope by investigating the top loadings. Based on the single-cell analysis of Raghavan et al (2021, Cell), the top 5 markers associated with the Classical subtype (scBasal state) are KRT6A, S100A2, KRT13, KRT17, LY6D and the top 5 markers associated with the basal subtype (scClassical state) are LGALS4, CTSE, TFF1, AGR2, TSPAN8."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Inspect top 5 loadings of each Epithelial state\nfor i in range(len(Statescope_simple_model.StateLoadings['Epithelial'].columns)):\n    print(f'Top 5 Epithelial State {i+1} markers: ',Statescope_simple_model.StateLoadings['Epithelial'].sort_values(f'Epithelial_{i}',ascending=False).head(5).index)\n\n"})}),"\n",(0,i.jsx)(t.p,{children:"Top 5 Epithelial State 1 markers:  Index(['PNLIP', 'CPA1', 'CPB1', 'PRSS1', 'PRSS2'], dtype='object')\nTop 5 Epithelial State 2 markers:  Index(['KRT17', 'S100A2', 'TGM2', 'KRT6A', 'ANXA1'], dtype='object')\nTop 5 Epithelial State 3 markers:  Index(['TFF1', 'REG4', 'CLDN18', 'CEACAM5', 'MUC5AC'], dtype='object')"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"The top markers of State 1 seem associated with exocrine/acinar cells"}),"\n",(0,i.jsx)(t.li,{children:"The top markers of State 2 include keratin genes, just like the scBasal State."}),"\n",(0,i.jsx)(t.li,{children:"The top marker of State 3 is the same as the scClassical State"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"2-investigate-whether-epithelial-state-scores-correspond-to-the-basalclassical-fractions-of-the-detailed-model",children:"2. Investigate whether 'Epithelial' state scores correspond to the Basal/Classical fractions of the detailed model"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# We calculate the correlation between Basal/Classical fractions estimated by the detailed model and the Epithelial state scores from the simple model\nCorr_matrix = pd.concat([Statescope_detailed_model.Fractions[['Classical','Basal']].apply(lambda x: x / sum(x), axis = 1), Statescope_simple_model.StateScores['Epithelial']], axis = 1).corr()\nfig, ax = plt.subplots(figsize=(3, 4))\nsns.heatmap(Corr_matrix.loc[Statescope_simple_model.StateScores['Epithelial'].columns,['Basal','Classical']], cmap = 'coolwarm')\nfig.show()\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"State Heatmap",src:s(2627).A+"",width:"300",height:"351"})}),"\n",(0,i.jsx)(t.p,{children:"Epithelial state 1 and 3 scores are correlated with the Classical fractions of the detailed model. Epithlial state 2 scores are correlated with the basal fractions in the detailed model."}),"\n",(0,i.jsx)(t.h2,{id:"3-investigate-whether-epithelial-states-retrieved-in-scrnaseq-profiles-stateretrieval-correspond-to-classicbasal-cells",children:"3. Investigate whether 'Epithelial' states retrieved in scRNAseq profiles (StateRetrieval) correspond to Classic/Basal cells"}),"\n",(0,i.jsx)(t.p,{children:"Here we will make use of the natural property of cNMF to retrieve cell state scores in new cell type-specific gene expression data (scRNAseq) using an existing state loadings matrix. Here we will uncover the intratumor heterogeneity by selecting one PDAC sample in the scRNAseq dataset with both basal and classical cells."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"scRNAseq_dataset.obs\n"})}),"\n",(0,i.jsx)(t.p,{children:"Lets select the cells of one tumor for state retrieval"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"fig, ax = plt.subplots(figsize=(5, 5))\nscRNAseq_dataset.obs['patient'] = [x.split(':')[0] for x in scRNAseq_dataset.obs.index]\nscRNAseq_subset = scRNAseq_dataset[((scRNAseq_dataset.obs.patient == 'Nov-6115-d0') & (scRNAseq_dataset.obs.major_celltype == 'Epithelial'))]\nsns.scatterplot(ax=ax, x=scRNAseq_subset.obsm['X_umap'][:,0], y=scRNAseq_subset.obsm['X_umap'][:,1], hue = scRNAseq_subset.obs.subtype, s=5)\nfig.show()\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"UMAP State",src:s(7207).A+"",width:"434",height:"428"})}),"\n",(0,i.jsx)(t.h2,{id:"state-retrieval",children:"State Retrieval"}),"\n",(0,i.jsx)(t.p,{children:"We will retrieve the Epithelial states detected from the bulk samples in single Epithelial cell profiles from one tumor"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"GEX = pd.DataFrame(scRNAseq_subset.X.toarray(), index = scRNAseq_subset.obs.index, columns = scRNAseq_subset.var.index)\nStateScores_scRNAseq = scope.StateRetrieval(GEX = GEX, Omega = Statescope_simple_model.scVar[['scVar_Epithelial']].rename(columns = {'scVar_Epithelial':'Epithelial'}), celltype='Epithelial', StateLoadings = Statescope_simple_model.StateLoadings['Epithelial'])\nStateScores_scRNAseq\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"fig, axes = plt.subplots(1,len(StateScores_scRNAseq.columns)+1,figsize=(25, 5))\naxes = axes.ravel()\nsns.scatterplot(ax=axes[0], x=scRNAseq_subset.obsm['X_umap'][:,0], y=scRNAseq_subset.obsm['X_umap'][:,1], hue = scRNAseq_subset.obs.subtype, s=5)\nfor i in range(len(StateScores_scRNAseq.columns)):\n    sns.scatterplot(ax=axes[i+1], x=scRNAseq_subset.obsm['X_umap'][:,0], y=scRNAseq_subset.obsm['X_umap'][:,1], hue = StateScores_scRNAseq[i], s=5,palette='viridis', legend = False)\n\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"State UMAP",src:s(3517).A+"",width:"1984",height:"428"})}),"\n",(0,i.jsx)(t.p,{children:"Here we observe an enrichment of State 3 scores in the classical cells and an enrichment of State 2 scores in the basal cells."}),"\n",(0,i.jsx)(t.p,{children:"Taken together, Statescope identified Epithelial state 2 as Basal and Epithelial state 3 as Classical."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"saving-loading-and-cpugpu-interoperability",children:"Saving, Loading, and CPU/GPU Interoperability"}),"\n",(0,i.jsxs)(t.p,{children:["Statescope models are not fully portable when using ",(0,i.jsx)(t.code,{children:"pickle.load"}),". Use the built-in ",(0,i.jsx)(t.code,{children:"Statescope.load()"})," and ",(0,i.jsx)(t.code,{children:"model.save()"})," helpers for CPU/GPU interoperability."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Example:"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'model = Statescope.load(\n    "/net/beegfs/users/P094398/StatescopeBenchmark/Benchmark/Data/Alldone.pkl",\n    device="cpu",\n)\n\nmodel.StateDiscovery()\nmodel.EcotypeDiscovery()\n\n# Save the model; if you ran on GPU, you can save it for CPU use like this\nmodel.save(\n    "/net/beegfs/users/P094398/Deployed_Dec/tutorial/Output/AllFinal_PBMC5.pkl",\n    to_cpu=True,\n)\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:'device="cpu"'})," when opening on CPU, and ",(0,i.jsx)(t.code,{children:'device="cuda"'})," when opening on GPU."]}),"\n",(0,i.jsx)(t.li,{children:"It is recommended to save your model after each module (e.g., after deconvolution, refinement, and state discovery)."}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},3517:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/Statescore-umap-036af32e203238df7d8ded4b3d7a1db5.png"},7207:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/Umap-state-e9baf642120824ab9c0e6533e97f21b4.png"},9108:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/coephcoeff2-d5f54df75203f09eb438d9c3cdc0208e.png"},869:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/cophcoeff-7fbec18f24d1900026579b305ef1b1f4.png"},2627:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/stateheatmap-1cabb40a78ef928044a9e091534b72e9.png"},6913:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/tumour_corr-e34af2e7aa4f1cd170359f5a9fb3359e.png"},3040:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/umap-annot-f455520342ca4b185b488adce22ad292.png"},8453:(e,t,s)=>{s.d(t,{R:()=>l,x:()=>o});var a=s(6540);const i={},n=a.createContext(i);function l(e){const t=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);